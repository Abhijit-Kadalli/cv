1:"$Sreact.fragment"
4:I[22016,["/cv/_next/static/chunks/3453aa51d43611fa.js"],""]
5:I[97367,["/cv/_next/static/chunks/ff1a16fafef87110.js","/cv/_next/static/chunks/247eb132b7f7b574.js"],"OutletBoundary"]
6:"$Sreact.suspense"
0:{"buildId":"kFzOVP70OyH93NmaRsBq2","rsc":["$","$1","c",{"children":[["$","main",null,{"className":"section blog-post","children":["$","div",null,{"className":"container","children":["$","article",null,{"className":"card","children":[["$","header",null,{"className":"card-header","children":[["$","h1",null,{"children":"Designing Real‑Time EEG Pipelines with LSL"}],["$","div",null,{"className":"meta","children":"October 2025"}]]}],["$","section",null,{"className":"post-section","children":["$","p",null,{"children":"When you're working with EEG data streams—especially in a real-time setup where multiple modalities converge—Lab Streaming Layer (LSL) becomes indispensable. In this post, I'll walk through how I designed a real-time EEG processing pipeline that synchronizes across modalities (vision, olfaction, and triggers), performs artifact rejection, and extracts temporal features—all with minimal latency."}]}],["$","section",null,{"className":"post-section","children":[["$","h2",null,{"children":"The Challenge: Multimodal Synchronization"}],["$","p",null,{"children":"In behavioral neuroscience experiments, data streams arrive from different sources at different rates:"}],["$","ul",null,{"children":[["$","li",null,{"children":"EEG at 500 Hz (or higher)"}],["$","li",null,{"children":"Sniff triggers at irregular intervals"}],["$","li",null,{"children":"Olfactory event markers"}],["$","li",null,{"children":"Vision timestamps from cameras"}]]}],["$","p",null,{"children":"The core problem? Getting all these streams to agree on a single, shared timeline. That's where LSL's network-based time synchronization shines."}]]}],["$","section",null,{"className":"post-section","children":[["$","h2",null,{"children":"Architecture Overview"}],["$","p",null,{"children":"The pipeline consists of three main stages:"}],["$","ol",null,{"children":[["$","li",null,{"children":[["$","strong",null,{"children":"Stream Acquisition:"}]," LSL inlets pull data from multiple outlets with automatic clock synchronization"]}],["$","li",null,{"children":[["$","strong",null,{"children":"Preprocessing:"}]," Bandpass filtering (0.5-50 Hz), artifact rejection using amplitude thresholds and gradient checks"]}],["$","li",null,{"children":[["$","strong",null,{"children":"Feature Extraction:"}]," Temporal features including Hjorth parameters (activity, mobility, complexity) and sample entropy"]}]]}]]}],["$","section",null,{"className":"post-section","children":[["$","h2",null,{"children":"Implementation Details"}],["$","p",null,{"children":"Here's how the real-time processing unfolds:"}],["$","ul",null,{"children":[["$","li",null,{"children":[["$","strong",null,{"children":"Buffering Strategy:"}]," Maintain a sliding window (e.g., 2 seconds) that updates with every new chunk"]}],["$","li",null,{"children":[["$","strong",null,{"children":"Filter Design:"}]," Butterworth bandpass with minimal phase distortion"]}],["$","li",null,{"children":[["$","strong",null,{"children":"Artifact Detection:"}]," Reject epochs where voltage exceeds ±100 μV or gradient exceeds a threshold"]}],["$","li",null,{"children":[["$","strong",null,{"children":"Feature Computation:"}]," Calculate Hjorth parameters and entropy metrics on clean epochs"]}],["$","li",null,{"children":[["$","strong",null,{"children":"Downstream ML:"}]," Features fed into an LSTM model for behavior prediction (~90% recall)"]}]]}]]}],["$","section",null,{"className":"post-section","children":[["$","h2",null,{"children":"Key Takeaways"}],["$","ul",null,{"children":[["$","li",null,{"children":"LSL's time synchronization is rock-solid for multimodal setups"}],["$","li",null,{"children":"Real-time artifact rejection is crucial—don't let bad epochs poison your features"}],["$","li",null,{"children":"Temporal features (Hjorth, entropy) capture dynamics that frequency-domain features miss"}],["$","li",null,{"children":"Keep latency low: process in chunks, but don't let buffer sizes balloon"}]]}]]}],["$","section",null,{"className":"post-section","children":[["$","h2",null,{"children":"Tools Used"}],["$","p",null,{"children":"Python • LSL (pylsl) • SciPy • NumPy • PyTorch (LSTM)"}]]}],"$L2"]}]}]}],null,"$L3"]}],"loading":null,"isPartial":false}
2:["$","p",null,{"style":{"marginTop":"2rem"},"children":["$","$L4",null,{"href":"/blog","className":"btn","children":"← Back to Blog"}]}]
3:["$","$L5",null,{"children":["$","$6",null,{"name":"Next.MetadataOutlet","children":"$@7"}]}]
7:null
